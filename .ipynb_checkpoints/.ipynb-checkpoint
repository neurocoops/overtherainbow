{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# EEG Scraper\n",
    "\n",
    "This script is used to interact with PubMed to determine how many EEG articles with time-frequency/topography plotting exist, and then determine what colour scheme they use."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import sys\n",
    "# !{sys.executable} -m pip install pymed\n",
    "# !{sys.executable} -m pip install pandas\n",
    "# !{sys.executable} -m pip install bs4\n",
    "# !{sys.executable} -m pip install matplotlib\n",
    "# !{sys.executable} -m pip install squarify\n",
    "# !{sys.executable} -m pip install plotly\n",
    "# !{sys.executable} -m pip install psutil\n",
    "# !{sys.executable} -m pip install hsluv"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from pymed import PubMed\n",
    "import pandas as pd\n",
    "import datetime"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Create a PubMed object that GraphQL can use to query\n",
    "# Note that the parameters are not required but kindly requested by PubMed Central\n",
    "# https://www.ncbi.nlm.nih.gov/pmc/tools/developers/\n",
    "pubmed = PubMed(tool=\"EEGSearchTool\", email=\"patrick.cooper@monash.edu\")\n",
    "# Create a GraphQL query in plain text\n",
    "query = \"(electroencephalography[MeSH Terms] OR electroencephalography[All Fields] OR eeg[All Fields]) AND time-frequency[All Fields]\"\n",
    "# Execute the query against the API\n",
    "results = pubmed.query(query, max_results=10000)\n",
    "results"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "title=[]\n",
    "authors = []\n",
    "year = []\n",
    "journal = []\n",
    "doi = []\n",
    "for article in results:\n",
    "    title.append(article.title)\n",
    "    authors.append(article.authors)\n",
    "    year.append(article.publication_date.year)\n",
    "    journal.append(article.journal)\n",
    "    doi.append(article.doi)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "df=pd.DataFrame(list(zip(authors,year,title,journal,doi)),columns=['authors','year','title','journal','doi'])\n",
    "df"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# store dataframe as .json file\n",
    "df.to_json (r'/Users/pcoo0005/Documents/GitHub/EEGScraper/PMC.json', orient='split')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import json\n",
    "import csv\n",
    "with open('PMC.json', 'r') as file:\n",
    "    data = json.load(file)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def pushAndSave(colour_list,colour_scheme,filename):\n",
    "    if colour_scheme != \"STOP\":\n",
    "        # we use \"STOP\" as a safe word to pause recording\n",
    "        # push to end of list\n",
    "        colour_list.append(colour_scheme)\n",
    "        with open(filename, 'w') as f:\n",
    "            # using csv.writer method from CSV package\n",
    "            write = csv.writer(f)\n",
    "            write.writerow(colour_list)\n",
    "        nPapers = len(colour_list)\n",
    "    else:\n",
    "        nPapers = \"STOPPED\"\n",
    "    return nPapers"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "count=0# change this to current value if running over multiple sessions\n",
    "\n",
    "suffix=data['data'][count][4]\n",
    "print(data['data'][count][2],data['data'][count][1])\n",
    "print(suffix)\n",
    "from IPython.display import IFrame\n",
    "\n",
    "url = 'https://www.doi.org/' + suffix\n",
    "# another website could be substituted here if needed...\n",
    "IFrame(url, width=800, height=200)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# * denotes no spectograph but a topoplot displayed (we'll filter these out later)\n",
    "filename = 'colour_schemes.csv'\n",
    "with open(filename) as f:\n",
    "    reader = csv.reader(f)\n",
    "    my_list = list(reader)\n",
    "colour_schemes = my_list[0]\n",
    "count = len(colour_schemes)\n",
    "count\n",
    "# if you want to stop for the session/day, colour_scheme = \"STOP\" will do the trick\n",
    "colour_scheme = \"greyscale\" \n",
    "count = pushAndSave(colour_schemes,colour_scheme,filename)\n",
    "print(count)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# read in filename\n",
    "filename = 'colour_schemes.csv'\n",
    "with open(filename) as f:\n",
    "    reader = csv.reader(f)\n",
    "    my_list = list(reader)\n",
    "colour_schemes = my_list[0]\n",
    "from collections import Counter\n",
    "# extract trial counts for used data\n",
    "article_count  = 0\n",
    "NA_count       = 0\n",
    "REMOVE_count   = 0\n",
    "NOACCESS_count = 0\n",
    "TOPOONLY_count = 0\n",
    "\n",
    "jet_count       = 0\n",
    "parula_count    = 0\n",
    "cbrewer_count   = 0\n",
    "hot_count       = 0\n",
    "greyscale_count = 0\n",
    "other_count     = 0\n",
    "\n",
    "for (ind,article) in enumerate(colour_schemes):\n",
    "    if data['data'][ind][1]>1999:\n",
    "        article_count += 1\n",
    "        if article == \"NA\":\n",
    "            NA_count += 1\n",
    "        elif article == \"REMOVE\":\n",
    "            REMOVE_count += 1\n",
    "        elif article == \"NOACCESS\":\n",
    "            NOACCESS_count += 1\n",
    "        elif article[-1]==\"*\":\n",
    "            TOPOONLY_count += 1\n",
    "        elif (article == \"jet\") | (article == \"jet-like\"):\n",
    "            jet_count += 1\n",
    "        elif article == \"parula\":\n",
    "            parula_count += 1\n",
    "        elif article == \"greyscale\":\n",
    "            greyscale_count += 1\n",
    "        elif ((article == \"RdBu\") | (article == \"RdYlBu\") | (article == \"RdPu\") | \n",
    "        (article == \"YlRdBkBu\") | (article == \"YlGrBu\") | (article == \"BuYl\") |\n",
    "        (article == \"YlPuRd\") | (article == \"RdYlGr\") | (article == \"Cyan-Black\") |\n",
    "        (article == \"YlRdBlackBl\") | (article == \"BlYlGr\") |\n",
    "        (article == \"YlRdBlackBu\") | (article == \"YlRdBuPr\") |\n",
    "        (article == \"Blues\") | (article == \"YlRdBu\") | (article == \"YlOrRd\") |\n",
    "        (article == \"YlBlack\") | (article == \"YlGrPrRd\") |\n",
    "        (article == \"YlRdPrBu\") |  (article == \"YlRdBlBu\") |\n",
    "        (article == \"BlRdYlBuPr\") | (article == \"YlRdBlBuPr\") |\n",
    "        (article == \"RdYlBuBl\") | (article == \"GnBk\") | (article == \"RdBl\") |\n",
    "        (article == \"PuBu\") | (article == \"GrBk\") | (article == \"RdBuGrBl\") |\n",
    "        (article == \"GrBuRdYl\") | (article == \"Reds\") | (article == \"RdPuBuGn\")):\n",
    "            cbrewer_count += 1\n",
    "        elif article == \"hot\":\n",
    "            hot_count += 1\n",
    "        elif (article == \"bone\") | (article == \"cool\") | (article == \"viridis\") | (article == \"plasma\"):\n",
    "            other_count +=1\n",
    "            \n",
    "valid_count = article_count - NA_count - REMOVE_count - NOACCESS_count - TOPOONLY_count\n",
    "\n",
    "\n",
    "scheme_totals={\"Jet\": round((jet_count/valid_count)*100,2),\n",
    "\"Greyscale\": round((greyscale_count/valid_count)*100,2),\n",
    "\"cbrewer\": round((cbrewer_count/valid_count)*100,2),\n",
    "\"Parula\": round((parula_count/valid_count)*100,2),\n",
    "\"Hot\": round((hot_count/valid_count)*100,2),\n",
    "\"Other\": round((other_count/valid_count)*100,2)}\n",
    "\n",
    "\n",
    "print(\"Total:\\t\\t\",article_count,\n",
    "     \"\\nNA:\\t\\t\",NA_count+TOPOONLY_count,\n",
    "     \"\\nREMOVE:\\t\\t\",REMOVE_count,\n",
    "     \"\\nNOACCESS:\\t\",NOACCESS_count,\n",
    "     \"\\nRemaining:\\t\",valid_count,\n",
    "      \"\\n---\",\n",
    "     \"\\nJet:\\t\\t\",round((jet_count/valid_count)*100,3),'\\b%',\n",
    "     \"\\nGreyscale:\\t\",round((greyscale_count/valid_count)*100,3),'\\b%',\n",
    "     \"\\ncbrewer:\\t\",round((cbrewer_count/valid_count)*100,3),'\\b%',\n",
    "     \"\\nParula:\\t\\t\",round((parula_count/valid_count)*100,3),'\\b%',\n",
    "     \"\\nHot:\\t\\t\",round((hot_count/valid_count)*100,3),'\\b%',\n",
    "     \"\\nOther:\\t\\t\",round((other_count/valid_count)*100,3),'\\b%',\n",
    "     \"\\nTotal:\\t\\t\",round(((jet_count + parula_count + hot_count + \n",
    "                            cbrewer_count + greyscale_count + other_count)/valid_count)*100,3))\n",
    "    \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "# extract year on year use of rainbow plot\n",
    "jet_props = [];\n",
    "for year in range(2000,2021):\n",
    "    inds=[i for (i,j) in enumerate(data['data']) if j[1]==year]\n",
    "    cols=[colour_schemes[i] for i in inds]\n",
    "    a=[i for (i,word) in enumerate(cols) if(word[-1] == \"*\")]\n",
    "    jet_props.append(round(cols.count(\"jet\")/(len(cols)-\n",
    "                             cols.count(\"NA\")-cols.count(\"NOACCESS\")-\n",
    "                             cols.count(\"REMOVE\")-len(a))*100,2))\n",
    "\n",
    "\n",
    "d={'Colour Scheme':['Jet','Greyscale','cbrewer','Parula','Hot','Other'],\n",
    "     'Amount':[scheme_totals['Jet'],scheme_totals['Greyscale'],\n",
    "              scheme_totals['cbrewer'],scheme_totals['Parula'],\n",
    "              scheme_totals['Hot'],scheme_totals['Other']]}\n",
    "df = pd.DataFrame(d, columns = ['Colour Scheme', 'Amount'])\n",
    "\n",
    "# print(df)\n",
    "\n",
    "from plotly.subplots import make_subplots\n",
    "import plotly.graph_objects as go\n",
    "\n",
    "labels  = [i for i in d['Colour Scheme']]\n",
    "# rename to more generic labels\n",
    "labels[labels.index(\"Jet\")]     = \"Rainbow\"\n",
    "labels[labels.index(\"cbrewer\")] = \"ColorBrewer\"\n",
    "values  = [i for i in d['Amount']]\n",
    "parents = [\"\" for i in d['Amount']]\n",
    "# print(labels,values,parents)\n",
    "\n",
    "fig = make_subplots(\n",
    "    rows=1, cols=2,\n",
    "    specs=[[{\"type\": \"treemap\"},{\"type\": \"scatter\"}]])\n",
    "\n",
    "fig.add_trace(go.Treemap(\n",
    "    labels = labels,\n",
    "    parents = parents,\n",
    "    values  = values,\n",
    "    textinfo = \"label\",\n",
    "    marker_colorscale = \"spectral\"),\n",
    "              row=1, col=1)\n",
    "\n",
    "fig.add_annotation(\n",
    "    xref=\"x domain\",yref=\"y domain\",\n",
    "    x=-1.3,y=1.1,\n",
    "    text=\"<b>a</b>\",\n",
    "    showarrow=False)\n",
    "\n",
    "fig.add_trace(go.Scatter(x=np.arange(2000,2021), \n",
    "                         y=jet_props,\n",
    "                         mode='lines+markers',\n",
    "                         name='lines+markers',\n",
    "                        marker_color='rgba(0, 0, 0, .7)'),\n",
    "              row=1, col=2)\n",
    "\n",
    "fig.add_annotation(\n",
    "    xref=\"x domain\",yref=\"y domain\",\n",
    "    x=-0.2,y=1.1,\n",
    "    text=\"<b>b</b>\",\n",
    "    showarrow=False)\n",
    "\n",
    "fig.add_annotation(\n",
    "        x=-.3,\n",
    "        y=0,\n",
    "        xref=\"x domain\",\n",
    "        yref=\"y domain\",\n",
    "        text=\"Other\",\n",
    "        showarrow=True,\n",
    "        align=\"center\",\n",
    "        arrowhead=2,\n",
    "        arrowsize=1,\n",
    "        arrowwidth=2,\n",
    "        arrowcolor=\"black\",\n",
    "        ax=35,\n",
    "        ay=35,\n",
    "        )\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "fig.update_layout(font=dict(\n",
    "    family=\"Helvetica\",\n",
    "    size=18,\n",
    "    color=\"Black\"),\n",
    "                  yaxis_title=\"<b>Rainbow Spectogram (%)</b>\",\n",
    "                  xaxis_title=\"<b>Year</b>\",\n",
    "                  plot_bgcolor=\"white\",\n",
    "                  xaxis=dict(showgrid=False,tickangle=360-45,tickfont=dict(family=\"Helvetica\",size=16),\n",
    "                               linewidth=2, linecolor='rgba(0, 0, 0, .7)'),\n",
    "                  yaxis=dict(showgrid=False,tickfont=dict(family=\"Helvetica\",size=16),\n",
    "                             linewidth=2, linecolor='rgba(0, 0, 0, .7)',range=[0,100]))\n",
    "\n",
    "fig.show()\n",
    "import os\n",
    "if not os.path.exists(\"images\"):\n",
    "    os.mkdir(\"images\")\n",
    "print(jet_props)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "# extract year on year use of rainbow plot\n",
    "alldata = {\n",
    "  \"author\": [],\n",
    "  \"year\": [],\n",
    "  \"title\": [],\n",
    "  \"journal\": [],\n",
    "  \"doi\": [],\n",
    "  \"cmap\": []\n",
    "}\n",
    "\n",
    "for year in range(2000,2021):\n",
    "    inds=[i for (i,j) in enumerate(data['data']) if j[1]==year]\n",
    "    for i in inds:\n",
    "        authors = data['data'][i][0]\n",
    "        title   = data['data'][i][2]\n",
    "        journal = data['data'][i][3]\n",
    "        doi     = data['data'][i][4]\n",
    "        cmap    = colour_schemes[i]\n",
    "        if cmap[-1]==\"*\":\n",
    "            cmap = \"NA\"\n",
    "        alldata[\"author\"].append(authors)\n",
    "        alldata[\"year\"].append(year)\n",
    "        alldata[\"title\"].append(title)\n",
    "        alldata[\"journal\"].append(journal)\n",
    "        alldata[\"doi\"].append(doi)\n",
    "        alldata[\"cmap\"].append(cmap)\n",
    "    \n",
    "df=pd.DataFrame(alldata)\n",
    "\n",
    "#create JSON file \n",
    "json_file = df.to_json(orient='table') \n",
    "\n",
    "#export JSON file\n",
    "with open('pubmed_data.json', 'w') as f:\n",
    "    f.write(json_file)"
   ]
  }
 ],
 "metadata": {
  "@webio": {
   "lastCommId": null,
   "lastKernelId": null
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
